---
keywords:
  - Nix
---

# HERP における Nix 活用

[HERP](https://herp.co.jp/) における開発では，実に様々な用途に [Nix](https://nixos.org/) が活用されている．Nix は非常に便利な代物なのだが，ドキュメントの貧弱さ，急峻な学習曲線，企業での採用事例の乏しさなどが相まって，広く普及しているとは言い難い状況である．しかし，Nix の利便性は，複数人での開発においてこそその本領が発揮されると考えている．この記事では HERP における事例の紹介を通じて，Nix の利便性や企業での活用可能性について紹介することを目的としている．

TODO 寄付の話

---

## Nix とは

Nix は，macOS および GNU Linux 上で利用できる，"the purely functional package manager" と銘打たれたパケッジ・マネジャーである．

一言で説明するのは難しいが，

- 優れた依存解決ツール
- パッケージマネージャ
- ビルドツール

といった側面を持つ．

Shopify でも Nix が活用されているらしく，中の人による入門記事があり，参考になる．

https://shopify.engineering/what-is-nix

## ビルド

Nix はパケッジ・マネジャーなので，当然ながらパケッジを作成する機能を有している．実に様々なものが，通常の意味でのパケッジに留まらないため，ここではビルドによって得られるものを「成果物」と呼ぶことにする．

社内では以下のようなものを Nix を用いてビルドしている．

### npm package

`$ npm publish` の対象となる tarball を `$ nix-build` でビルドできるようにしている．

https://github.com/herp-inc/environmen-ts/blob/master/default.nix

TODO ビルド用の一時ディレクトリにコピーしてビルドしてくれるから，カレントディレクトリを汚さない点が地味に嬉しい．

### アプリケーション

(特に Haskell 製)

[IOHK](https://iohk.io/) が haskell.nix という TODO を公開している．

https://input-output-hk.github.io/haskell.nix/

### アプリケーションの Docker image

[`pkgs.dockerTools`](http://ryantm.github.io/nixpkgs/builders/images/dockertools/) を利用して，Docker image をビルドするための derivation を記述している．

他の derivation から作られた成果物をそのまま `/nix/store/` 以下にコピーし

## 開発環境の提供

[`nix-shell`](https://nixos.org/manual/nix/unstable/command-ref/nix-shell.html) というコマンドを利用すると，Nix を通じて依存を解決・インストールし，必要なディレクトリに `$PATH` が通されたシェルが立ち上がる．これを利用して，開発や運用に必要な依存をプロジェクトごとにあらかじめ宣言しておくことで，環境を構築・提供することができる．

TODO オペレーション環境の提供

Nix で開発環境を提供することは，以下のような利点があると考えている．

- 言語に依存しない
- 宣言的に記述できる
- コードベースとして記述できる
- 再現性が高い
- 環境を汚さない
- 透過的に利用できる

### 言語に依存しない

例えば，プロジェクトごとに利用する Node.js のヴァージョンを切り替えたい場合，nvm, nodenv, n などの利用が選択肢として挙がってくるだろう．同様に，Python であれば pyenv，Ruby であれば rbenv や rvm などを採用するケースが多いのではないかと推察する．

上記のような依存だけで済むなら anyenv を導入すればいいかもしれないが，開発に必要な依存というものは残念ながらプログラミング言語の処理系だけに留まらない。 社内での事例を例に取ると，AWS CodeArtifact に置かれたライブラリや，Amazon ECR に置かれた Docker image を取得するための認可を行うため，AWS CLIが必要になってくる．その前段として．そもそも AWS へのアクセス権限を得るためには [saml2aws](https://github.com/Versent/saml2aws) を利用している[^1]．また，リポジトリ内に置いておきたいスクリプトから jq などを利用したい場合もあるだろう．実行可能ファイルのみならず，動的ライブラリが依存として必要になるケースもある．例えば，MySQL のCライブラリへのFFIを行うライブラリを利用する場合，ビルド時に `mysql.h` が必要になったりする．

Nix は特定の言語に依存しないため，上に挙げたもののうちどのような種類の依存でも解決することができる．

### 宣言的に記述できる

プロジェクトに必要な依存は Nix expression language を用いて宣言的に記述する．宣言的に記述できるがゆえに，依存のインストールは自動的に冪等であり，開発者が中間状態について気に掛ける必要はない．また，不要になった依存を自動的に検出し，ガーベジ・コレクションを行うこともできる．

### コードベースに記述できる

環境構築の煩わしさの一因として，その手順を記したドキュメントが頻繁に参照されるものでないがゆえに，しばしば最新の状態に保たれていないという事態があるのではないかと思う．個人的には，こうした環境構築の手順は，ドキュメントではなくプログラムとして記述されるべきだと考えている．最新の状態に保たれるためには絶えず検証がなされる必要があるが，こうした検証を機械的に行うためには，それ自体が実行・評価可能なプログラムとして記述されていないと途端に難しくなるからだ．

Nix を使えば，こうしたプラクティスを実現することができる．あるプロジェクトの開発に必要な環境は，`shell.nix` というファイルに記述し，リポジトリにコミットする．このファイルに記述された内容は，開発者が日頃開発を行う際 `nix-shell` を立ち上げる度に検証される．これが満足な開発環境を提供しない場合，そもそも開発が行えないため，必然的に修正の対象となる．このようにして，環境構築にまつわる問題が，我々が日常的に行うソフトウェア・エンジニアリングの問題に還元される．

### 再現性が高い

異なる開発者間で，異なるヴァージョンのソフトウェアがインストールされているが故に問題が生じるといった場面は，典型的ではあるが馬鹿馬鹿しいものでもある．理想的には，パッチヴァージョンはもちろんのこと，ビルド時に指定されるオプションまでもが一致しているべきだろう．こうした問題は環境構築の再現性を高めることによって解消することができる．

Nix が the "purely functional" package manager と銘打たれている理由のひとつに，あらゆる依存関係を明示的に取り扱うという特徴がある．同じ入力から作成されたパッケージは同一のものが作成されるという意味で "purely functional" である．

社内では，`nixpkgs` の特定の revision を固定するために [niv](https://github.com/nmattia/niv) を利用している[^2]．

[開発環境と本番環境の差異を生じさせない](https://12factor.net/dev-prod-parity)ことにも貢献する．

同一の derivation からは理論上常に同一の成果物がビルドされるはずである．TODOキャッシュ．

### 環境を汚さない

Nix によってインストールされた依存はすべて `/nix/store/` 以下に格納されるため，`/usr/local/bin/` などのディレクトリを汚す心配がない．また，`/nix/store/` 以下に作成されるファイル名には derivation から計算されたハッシュ値が付与されるため，パッチヴァージョンはおろか，ビルド時に与えるオプションが異なれば別々のディレクトリに保存される．こうした潔癖とまで言える仕組みにより，Nix によって新たな依存をインストールした際には，既存のものを壊すといったことが起こらず，dependency hell に煩わされることはない．

### 透過的に利用できる

Nix を用いた開発環境構築の利点を説明する際に，「Docker とは何が異なるのか」と問われることがしばしばある．答えは明確で，Nix は Docker とは異なり，コンテナ仮想化などを行うものではない．Nix が行う仕事は，単に依存を解決し，必要なもののビルドを行い，`$PATH` を通すだけである．

コンテナ仮想化は便利な技術ではあるものの，それに起因する煩わしさも引き起こす．例えば，ホストマシンのファイルシステムにアクセスしたい場合，明示的にヴォリュームのマウントを行う必要がある．例えば，AWS CLI を利用して Amazon S3 からファイルを取得する場合，公式の Docker image を使うケースでは，以下のようなコマンドを実行する必要がある．

```sh
$ docker run --rm -it -v ~/.aws:/root/.aws -v $(pwd):/aws amazon/aws-cli s3 cp s3://my-bucket/path/to/object .
```

これに対し，Nix を利用して AWS CLI を調達する場合は，コンテナ仮想化に伴う煩わしい問題は生じないため，TODO．

```sh
$ aws s3 cp s3://my-bucket/path/to/object .
```

また，HERP における開発では，Nix と合わせて [direnv](https://direnv.net/) も利用している．[`direnv-stdlib`](https://direnv.net/man/direnv-stdlib.1.html) の [`use nix`](https://direnv.net/man/direnv-stdlib.1.html#codeuse-nix-code) を使えば，プロジェクトのディレクトリに `cd` するだけで，解決された依存が自動的にインストールされ，`$PATH` が通される．

## CI

社内での CI には主に[^3] GitHub Actions を利用しているが，[Actions Runner](https://github.com/actions/runner) をベースに，Nix が out of the box で利用できるコンテナ上でジョブが実行されるようになっている．ビルドキャッシュの保存用に Amazon S3 のバケットを用意しており，これが trusted substitutor として最初から設定されているので，ジョブの最後に `$ nix copy` でキャッシュを保存すれば，次回以降のビルドで再利用することができる．

また，CI 上で必要になる依存も Nix を経由して入手できるという点も魅力的である．こうした依存も `shell.nix` に記述しておけば，手元での開発環境と CI 上での環境で同一のTODOを用意することは容易い．

## 社内用 CLI の提供

TODO codex の話

## 将来の構想

- 開発環境でのキャッシュ

## 広告

https://discord.gg/TYytzedtbe

## 脚注

[^1]: OAuth 2.0 Device Authorization Grant を利用した形式への移行を計画している．
[^2]: flakes が stable になればそちらへの移行を検討することになるだろう．
[^3]: 以前は CircleCI を利用しており，一部残っている．
